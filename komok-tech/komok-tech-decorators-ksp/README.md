# Decorators KSP Plugin

This method generates compile time decorators, i.e., wrap execution of a certain method in some code generated by this KSP plugin.
Plugin itself does not emit any logic and delegates it to Decorator Plugins, some plugins might be: Logging, Cache, Retry, etc.
Decorators Plugins loaded using SPI protocol.
Interface of Decorator Plugins includes at least the following methods:
1. Method provides an annotation type (s) that it's interested in. All methods/classes marked with this interface will be passed in other methods.
2. Method that provides a list of required context params on the method. For many decorators some data is required, like store for cache, or TransactionContext for Transaction.
So KSP Plugin can validate that the required context parameter exists on the method.
3. Method that would return fqn of wrapping function. We will have a standard number of wrapping functions, starting from 0 to 21. Each function for a different number of parameters. Meta information about original method and logger passed as context parameter.
4. Method that accepts all methods/classes decorated and allows generating arbitrary code

KSP Plugin will work in the following way:

1. Load all decorator plugins using SPI, log-loaded plugins
2. Resolves all methods/classes with annotations (resolves annotations, having any decorator annotation on the method directly, completely overrides decorators from the class)
3. Validates that class is either interface of having open class and methods
4. Generates a decorator class for interface or class
5. Calls ksp plugins to generate the body of class
6. Calls ksp plugins to generate arbitrary code, pass if the decorator class is generated, and either it's subclass or interface implementation.

Make sure that plugin will work in multi-project setup and would work correctly with KSP incremental compilation.
Make sure that coroutines are supported as well.

## Implement the following decorators

- Cached
- CircuitBreaker
- Retry
