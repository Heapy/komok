package io.heapy.komok.tech.decorators.lib

import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.slf4j.event.Level
import kotlin.jvm.java
import kotlin.reflect.KFunction

// This is expected code to come with a Decorator Plugin and generated by KSP and Plugin

// plugin library, mark user's source code
private annotation class Retry
private annotation class Log(val level: Level = Level.INFO)

// user's source code
@Log(level = Level.ERROR)
@Retry
private open class Service : BaseService {
    var i = 0
    override fun doSomething(hello: String): String {
        if (i++ < 2) {
            throw RuntimeException("failed")
        }
        return hello
    }

    override suspend fun doSomethingElse() {
        println("do something else")
    }
}

// example with interface wrapped with decorators
@Log
@Retry
private interface BaseService {
    fun doSomething(hello: String): String
    suspend fun doSomethingElse()
}

// plugin library, used in users's source code
context(log: Logger)
private inline fun <T, R> retry1(
    t1: T,
    call: (T) -> R,
): R {
    val maxAttempts = 3
    var attempt = 0

    while (true) {
        try {
            return call(t1)
        } catch (e: Exception) {
            attempt++
            if (attempt == maxAttempts) {
                throw e
            } else {
                log.warn(
                    "retrying ${e.message}",
                    e,
                )
            }
            Thread.sleep(1000L * (1 shl attempt)) // exponential backoff
        }
    }
}

// plugin library, used in users's source code
context(log: Logger)
private inline fun <R> retry0(
    call: () -> R,
): R {
    val maxAttempts = 3
    var attempt = 0

    while (true) {
        try {
            return call()
        } catch (e: Exception) {
            attempt++
            if (attempt == maxAttempts) {
                throw e
            } else {
                log.warn(
                    "retrying ${e.message}",
                    e,
                )
            }
            Thread.sleep(1000L * (1 shl attempt)) // exponential backoff
        }
    }
}

// plugin library, used in users's source code
context(log: Logger, kfunction: KFunction<R>, annotation: Log)
private inline fun <T, R> log1(
    t1: T,
    call: (T) -> R,
): R {
    val name = kfunction.name
    log.atLevel(annotation.level).log("calling $name($t1)")
    try {
        val result = call(t1)
        log.atLevel(annotation.level).log("$name($t1) returned $result")
        return result
    } catch (e: Exception) {
        log.atLevel(annotation.level).log("failed to call $name($t1) with exception: $e")
        throw e
    }
}

// plugin library, used in users's source code
context(log: Logger, kfunction: KFunction<R>, annotation: Log)
private inline fun <R> log0(
    call: () -> R,
): R {
    val name = kfunction.name
    log.atLevel(annotation.level).log("calling $name()")
    try {
        val result = call()
        log.atLevel(annotation.level).log("$name() returned $result")
        return result
    } catch (e: Exception) {
        log.atLevel(annotation.level).log("failed to call $name() with exception: $e")
        throw e
    }
}

// Generated code by KSP
private open class ServiceDecorator : Service() {
    private val log = LoggerFactory.getLogger(Service::class.java)

    override fun doSomething(hello: String): String {
        return context(log, Service::doSomething, Service::class.annotations.filterIsInstance<Log>().single()) {
            log1(
                hello,
            ) { p1 ->
                retry1(
                    p1,
                ) { p2 ->
                    super.doSomething(p2)
                }
            }
        }
    }

    override suspend fun doSomethingElse() {
        return context(log, Service::doSomethingElse, Service::class.annotations.filterIsInstance<Log>().single()) {
            log0 {
                retry0 {
                    super.doSomethingElse()
                }
            }
        }
    }
}

private open class BaseServiceDecorator(
    private val service: Service,
) : BaseService {
    private val log = LoggerFactory.getLogger(BaseService::class.java)
    override fun doSomething(hello: String): String {
        return context(log, Service::doSomething, Service::class.annotations.filterIsInstance<Log>().single()) {
            log1(
                hello
            ) { p1 ->
                retry1(
                    p1
                ) { p2 ->
                    service.doSomething(p2)
                }
            }
        }
    }

    override suspend fun doSomethingElse() {
        return context(log, Service::doSomethingElse, Service::class.annotations.filterIsInstance<Log>().single()) {
            log0 {
                retry0 {
                    service.doSomethingElse()
                }
            }
        }
    }
}

// For testing
suspend fun main() {
    ServiceDecorator().doSomething("hello")
    ServiceDecorator().doSomethingElse()

    BaseServiceDecorator(Service()).doSomething("hello")
    BaseServiceDecorator(Service()).doSomethingElse()
}
